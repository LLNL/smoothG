<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>smoothG: smoothg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="smoothg_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">smoothG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">smoothg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The overall namespace for the smoothG project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1FiniteVolumeUpscale.html">FiniteVolumeUpscale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct upscaler with finite element information.  <a href="classsmoothg_1_1FiniteVolumeUpscale.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1GraphCoarsen.html">GraphCoarsen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Usually used wrapped in <a class="el" href="classsmoothg_1_1Mixed__GL__Coarsener.html" title="Abstract class for coarsening a mixed graph Laplacian problem. ">Mixed_GL_Coarsener</a>.  <a href="classsmoothg_1_1GraphCoarsen.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1GraphGenerator.html">GraphGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator of random graphs based on the Watts-Strogatz model.  <a href="classsmoothg_1_1GraphGenerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1GraphTopology.html">GraphTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent the topology of a graph as it is coarsened.  <a href="classsmoothg_1_1GraphTopology.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1GraphUpscale.html">GraphUpscale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use upscaling as operator.  <a href="classsmoothg_1_1GraphUpscale.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1HybridSolver.html">HybridSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybridization solver for saddle point problems.  <a href="classsmoothg_1_1HybridSolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1LocalMixedGraphSpectralTargets.html">LocalMixedGraphSpectralTargets</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a mixed form graph Laplacian, do local eigenvalue problems, and generate targets in parallel.  <a href="classsmoothg_1_1LocalMixedGraphSpectralTargets.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1LocalGraphEdgeSolver.html">LocalGraphEdgeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver for local saddle point problems, see the formula below.  <a href="classsmoothg_1_1LocalGraphEdgeSolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1MetisGraphPartitioner.html">MetisGraphPartitioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap Metis in a C++ class for partitioning a graph.  <a href="classsmoothg_1_1MetisGraphPartitioner.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1MinresBlockSolver.html">MinresBlockSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block diagonal preconditioned MINRES solver for saddle point problem.  <a href="classsmoothg_1_1MinresBlockSolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1MinresBlockSolverFalse.html">MinresBlockSolverFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1MinresBlockSolver.html" title="Block diagonal preconditioned MINRES solver for saddle point problem. ">MinresBlockSolver</a> acts on "true" dofs, this one does not.  <a href="classsmoothg_1_1MinresBlockSolverFalse.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1Mixed__GL__Coarsener.html">Mixed_GL_Coarsener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for coarsening a mixed graph Laplacian problem.  <a href="classsmoothg_1_1Mixed__GL__Coarsener.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1MixedLaplacianSolver.html">MixedLaplacianSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for solvers of graph Laplacian problems.  <a href="classsmoothg_1_1MixedLaplacianSolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1MixedMatrix.html">MixedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapuslates the mixed form of a graph in saddle-point form.  <a href="classsmoothg_1_1MixedMatrix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1SharedEntityCommunication.html">SharedEntityCommunication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles sharing information across processors, where that information belongs to entities that are also shared across processors.  <a href="classsmoothg_1_1SharedEntityCommunication.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1SpectralAMG__MGL__Coarsener.html">SpectralAMG_MGL_Coarsener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use spectral AMG to coarsen the mixed graph Laplacian.  <a href="classsmoothg_1_1SpectralAMG__MGL__Coarsener.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1Upscale.html">Upscale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use upscaling as operator.  <a href="classsmoothg_1_1Upscale.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscaleBlockSolve.html">UpscaleBlockSolve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1UpscaleBlockSolve.html" title="UpscaleBlockSolve performs the same thing as Upscale, but in mixed form. ">UpscaleBlockSolve</a> performs the same thing as <a class="el" href="classsmoothg_1_1Upscale.html" title="Use upscaling as operator. ">Upscale</a>, but in mixed form.  <a href="classsmoothg_1_1UpscaleBlockSolve.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscaleFineSolve.html">UpscaleFineSolve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1UpscaleFineSolve.html" title="UpscaleFineSolve Solves the fine problem in primal form as its operation. ">UpscaleFineSolve</a> Solves the fine problem in primal form as its operation.  <a href="classsmoothg_1_1UpscaleFineSolve.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscaleFineBlockSolve.html">UpscaleFineBlockSolve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1UpscaleFineSolve.html" title="UpscaleFineSolve Solves the fine problem in primal form as its operation. ">UpscaleFineSolve</a> Solves the fine problem in the mixed form as its operation.  <a href="classsmoothg_1_1UpscaleFineBlockSolve.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscaleCoarseSolve.html">UpscaleCoarseSolve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1UpscaleCoarseSolve.html" title="UpscaleCoarseSolve Solves the coarse problem in the primal form as its operation. ...">UpscaleCoarseSolve</a> Solves the coarse problem in the primal form as its operation.  <a href="classsmoothg_1_1UpscaleCoarseSolve.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscaleCoarseBlockSolve.html">UpscaleCoarseBlockSolve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsmoothg_1_1UpscaleCoarseBlockSolve.html" title="UpscaleCoarseBlockSolve Solves the coarse problem in the mixed form as its operation. ">UpscaleCoarseBlockSolve</a> Solves the coarse problem in the mixed form as its operation.  <a href="classsmoothg_1_1UpscaleCoarseBlockSolve.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsmoothg_1_1mpi__session.html">mpi_session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A quick-and dirty RAII struct for managing the MPI resource.  <a href="structsmoothg_1_1mpi__session.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1UpscalingStatistics.html">UpscalingStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect information about upscaling process for systematic output.  <a href="classsmoothg_1_1UpscalingStatistics.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1ParGraph.html">ParGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage topological information for the coarsening.  <a href="classsmoothg_1_1ParGraph.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1FiniteVolumeMassIntegrator.html">FiniteVolumeMassIntegrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite volume integrator.  <a href="classsmoothg_1_1FiniteVolumeMassIntegrator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1SVD__Calculator.html">SVD_Calculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes SVD of mfem::DenseMatrix to find linear dependence.  <a href="classsmoothg_1_1SVD__Calculator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1Eigensolver.html">Eigensolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense eigensolver based on LAPACK dsyevx.  <a href="classsmoothg_1_1Eigensolver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmoothg_1_1InversePermeabilityFunction.html">InversePermeabilityFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for working with the SPE10 data set.  <a href="classsmoothg_1_1InversePermeabilityFunction.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a573089cfdbcc5cab22e56dac68581703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a573089cfdbcc5cab22e56dac68581703"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a573089cfdbcc5cab22e56dac68581703">GenerateGraph</a> (MPI_Comm comm, int nvertices, int mean_degree, double beta, double seed)</td></tr>
<tr class="memdesc:a573089cfdbcc5cab22e56dac68581703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vertex edge relationship for a WattsStrogatz random graph. <br/></td></tr>
<tr class="separator:a573089cfdbcc5cab22e56dac68581703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fb8c426c39e89c98b4be6981f701b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad9fb8c426c39e89c98b4be6981f701b6">Print</a> (const mfem::DenseMatrix &amp;mat, const std::string &amp;label=&quot;&quot;, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:ad9fb8c426c39e89c98b4be6981f701b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dense matrices. <br/></td></tr>
<tr class="separator:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94e9c24a58278f441192080533ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd94e9c24a58278f441192080533ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Print</b> (const mfem::SparseMatrix &amp;mat, const std::string &amp;label, std::ostream &amp;out)</td></tr>
<tr class="separator:aafd94e9c24a58278f441192080533ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0eacbfc58943662b27572af61d4391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b0eacbfc58943662b27572af61d4391"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4b0eacbfc58943662b27572af61d4391">Transpose</a> (const mfem::SparseMatrix &amp;A)</td></tr>
<tr class="memdesc:a4b0eacbfc58943662b27572af61d4391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transpose of a matrix. <br/></td></tr>
<tr class="separator:a4b0eacbfc58943662b27572af61d4391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f21a9a7d1292763ed8d1343ba02ddc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a73f21a9a7d1292763ed8d1343ba02ddc">Mult</a> (const mfem::SparseMatrix &amp;A, const mfem::SparseMatrix &amp;B)</td></tr>
<tr class="memdesc:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two sparse matrices C = A * B. <br/></td></tr>
<tr class="separator:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad122480ce3940768078a156f33296211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad122480ce3940768078a156f33296211"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad122480ce3940768078a156f33296211">Threshold</a> (const mfem::SparseMatrix &amp;mat, double tol=1e-8)</td></tr>
<tr class="memdesc:ad122480ce3940768078a156f33296211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove small entries from a matrix. <br/></td></tr>
<tr class="separator:ad122480ce3940768078a156f33296211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ed67c6b7549e2d5d5c77f5f15fd4641"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4ed67c6b7549e2d5d5c77f5f15fd4641">TableToSparse</a> (const mfem::Table &amp;table)</td></tr>
<tr class="memdesc:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sparse matrix from a table. <br/></td></tr>
<tr class="separator:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546d3176c315dd1dd67271f9a80a937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af546d3176c315dd1dd67271f9a80a937"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>RAP</b> (const mfem::HypreParMatrix &amp;R, const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:af546d3176c315dd1dd67271f9a80a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95fe015f108f8913febf1d7045c6893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa95fe015f108f8913febf1d7045c6893"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>RAP</b> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:aa95fe015f108f8913febf1d7045c6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8af82a4c75783a1c00e4a262b299bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8e8af82a4c75783a1c00e4a262b299bb">BroadCast</a> (MPI_Comm comm, mfem::SparseMatrix &amp;mat)</td></tr>
<tr class="memdesc:a8e8af82a4c75783a1c00e4a262b299bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a SparseMatrix on processor 0 to all other processors. <br/></td></tr>
<tr class="separator:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462c47e554826e19abcf3f9e42f277c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8462c47e554826e19abcf3f9e42f277c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8462c47e554826e19abcf3f9e42f277c">MultSparseDense</a> (const mfem::SparseMatrix &amp;A, mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a8462c47e554826e19abcf3f9e42f277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense. <br/></td></tr>
<tr class="separator:a8462c47e554826e19abcf3f9e42f277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24b00fa9f7f31b0d18a12ce09fca656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ac24b00fa9f7f31b0d18a12ce09fca656">MultSparseDenseTranspose</a> (const mfem::SparseMatrix &amp;A, mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense, but C is kept transposed. <br/></td></tr>
<tr class="separator:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa208a6e56502beb7962055df7684e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a78aa208a6e56502beb7962055df7684e">Mult_a_VVt</a> (const double a, const mfem::Vector &amp;v, mfem::DenseMatrix &amp;aVVt)</td></tr>
<tr class="memdesc:a78aa208a6e56502beb7962055df7684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (scaled) outer product <img class="formulaInl" alt="$ a v v^T $" src="form_17.png"/>.  <a href="#a78aa208a6e56502beb7962055df7684e">More...</a><br/></td></tr>
<tr class="separator:a78aa208a6e56502beb7962055df7684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac15dbc5f2d35bc991c4240be40e38a99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ac15dbc5f2d35bc991c4240be40e38a99">SetConstantValue</a> (mfem::HypreParMatrix &amp;pmat, double c)</td></tr>
<tr class="memdesc:ac15dbc5f2d35bc991c4240be40e38a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values of the non zero entries of a HypreParMatrix to 'c'. <br/></td></tr>
<tr class="separator:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c3bcb3238d0d372b1459370b642dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87c3bcb3238d0d372b1459370b642dc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ae87c3bcb3238d0d372b1459370b642dc">PartitionToMatrix</a> (const mfem::Array&lt; int &gt; &amp;partition, int nparts)</td></tr>
<tr class="memdesc:ae87c3bcb3238d0d372b1459370b642dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the relation table aggregate to vertex from partition. <br/></td></tr>
<tr class="separator:ae87c3bcb3238d0d372b1459370b642dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5681811902cac31df51a44d9c57e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5681811902cac31df51a44d9c57e1d"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afb5681811902cac31df51a44d9c57e1d">SparseIdentity</a> (int size)</td></tr>
<tr class="memdesc:afb5681811902cac31df51a44d9c57e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an identity matrix (as a SparseMatrix) of size 'size'. <br/></td></tr>
<tr class="separator:afb5681811902cac31df51a44d9c57e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc66645634ac5a0d2bbac57b2abe508c"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afc66645634ac5a0d2bbac57b2abe508c">SparseIdentity</a> (int rows, int cols, int row_offset=0, int col_offset=0)</td></tr>
<tr class="memdesc:afc66645634ac5a0d2bbac57b2abe508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an rectangular identity matrix (as a SparseMatrix)  <a href="#afc66645634ac5a0d2bbac57b2abe508c">More...</a><br/></td></tr>
<tr class="separator:afc66645634ac5a0d2bbac57b2abe508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#adf1c72e21539d2be5cbe3bb039faf9ce">VectorToMatrix</a> (const mfem::Vector &amp;vect)</td></tr>
<tr class="memdesc:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a diagonal matrix with the entries specified by a vector.  <a href="#adf1c72e21539d2be5cbe3bb039faf9ce">More...</a><br/></td></tr>
<tr class="separator:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122311dc2c2578bd483a89334938cfad"><td class="memItemLeft" align="right" valign="top">mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a122311dc2c2578bd483a89334938cfad">ParAdd</a> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;B)</td></tr>
<tr class="memdesc:a122311dc2c2578bd483a89334938cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two parallel matrices C = A + B.  <a href="#a122311dc2c2578bd483a89334938cfad">More...</a><br/></td></tr>
<tr class="separator:a122311dc2c2578bd483a89334938cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48002c1039dcb0c8301b45364394c9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af48002c1039dcb0c8301b45364394c9c">MaxNorm</a> (const mfem::HypreParMatrix &amp;A)</td></tr>
<tr class="memdesc:af48002c1039dcb0c8301b45364394c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute max norm of parallel matrix.  <a href="#af48002c1039dcb0c8301b45364394c9c">More...</a><br/></td></tr>
<tr class="separator:af48002c1039dcb0c8301b45364394c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14519b1c256224b0cc87002eded8c23"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af14519b1c256224b0cc87002eded8c23">ExtractRowAndColumns</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, mfem::Array&lt; int &gt; &amp;colMapper, bool colMapper_not_filled=true)</td></tr>
<tr class="memdesc:af14519b1c256224b0cc87002eded8c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a matrix.  <a href="#af14519b1c256224b0cc87002eded8c23">More...</a><br/></td></tr>
<tr class="separator:af14519b1c256224b0cc87002eded8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4246dcf5055f29128164b2ad25c0f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad4246dcf5055f29128164b2ad25c0f76">ExtractSubMatrix</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, const mfem::Array&lt; int &gt; &amp;colMapper, mfem::DenseMatrix &amp;A_sub)</td></tr>
<tr class="memdesc:ad4246dcf5055f29128164b2ad25c0f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a sparse matrix, return it dense.  <a href="#ad4246dcf5055f29128164b2ad25c0f76">More...</a><br/></td></tr>
<tr class="separator:ad4246dcf5055f29128164b2ad25c0f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a5e9d52f60e116a5026a1992b62dfe0cc">Full</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;Adense)</td></tr>
<tr class="memdesc:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of a SparseMatrix.  <a href="#a5e9d52f60e116a5026a1992b62dfe0cc">More...</a><br/></td></tr>
<tr class="separator:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7d1e6bee3cd75b7885d7b69ae5b5526f">FullTranspose</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;AdenseT)</td></tr>
<tr class="memdesc:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of transpose of a SparseMatrix.  <a href="#a7d1e6bee3cd75b7885d7b69ae5b5526f">More...</a><br/></td></tr>
<tr class="separator:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264079f7cc4cecd453569a1c0354ad3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2264079f7cc4cecd453569a1c0354ad3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2264079f7cc4cecd453569a1c0354ad3">Concatenate</a> (const mfem::Vector &amp;a, const mfem::DenseMatrix &amp;b, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a2264079f7cc4cecd453569a1c0354ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend the (column) vector a to the matrix b. <br/></td></tr>
<tr class="separator:a2264079f7cc4cecd453569a1c0354ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3393af3ae95d1a28009e2784476ba92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3393af3ae95d1a28009e2784476ba92c">Deflate</a> (mfem::DenseMatrix &amp;a, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3393af3ae95d1a28009e2784476ba92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all column vectors of a orthogonal to v.  <a href="#a3393af3ae95d1a28009e2784476ba92c">More...</a><br/></td></tr>
<tr class="separator:a3393af3ae95d1a28009e2784476ba92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#aee8776e75d8f97d83b52ad0e3fed8f88">orthogonalize_from_constant</a> (mfem::Vector &amp;vec)</td></tr>
<tr class="memdesc:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector from the constant vector.  <a href="#aee8776e75d8f97d83b52ad0e3fed8f88">More...</a><br/></td></tr>
<tr class="separator:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2bcfe4bfbd5b1cc452acd5139b512b1b">par_orthogonalize_from_constant</a> (mfem::Vector &amp;vec, int globalsize)</td></tr>
<tr class="memdesc:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector from the constant vector.  <a href="#a2bcfe4bfbd5b1cc452acd5139b512b1b">More...</a><br/></td></tr>
<tr class="separator:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad61b4c310f8bb76f5524294d46b8ce4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>par_orthogonalize_from_constant</b> (mfem::HypreParVector &amp;vec)</td></tr>
<tr class="separator:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d80d522d87be6998895981663dcb336"><td class="memItemLeft" align="right" valign="top">std::vector&lt; mfem::Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2d80d522d87be6998895981663dcb336">get_blocks</a> (const std::vector&lt; std::unique_ptr&lt; mfem::BlockVector &gt;&gt; &amp;blockvecs, int block_num)</td></tr>
<tr class="separator:a2d80d522d87be6998895981663dcb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memItemLeft" align="right" valign="top">mfem::DenseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7b7f3460c5e52ae27462a9a81a1495df">get_sq_differences_matrix</a> (const std::vector&lt; mfem::Vector &gt; &amp;vecs, const mfem::SparseMatrix *inner_prod_mat, bool diag_sq_norms)</td></tr>
<tr class="separator:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b97167d68e040b91c3c8eba672c67e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b97167d68e040b91c3c8eba672c67e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6b97167d68e040b91c3c8eba672c67e9">GenerateOffsets</a> (MPI_Comm comm, int N, HYPRE_Int loc_sizes[], mfem::Array&lt; HYPRE_Int &gt; *offsets[])</td></tr>
<tr class="memdesc:a6b97167d68e040b91c3c8eba672c67e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs. <br/></td></tr>
<tr class="separator:a6b97167d68e040b91c3c8eba672c67e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72242e6f25ceaa18cdce6ca81c41ba73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a72242e6f25ceaa18cdce6ca81c41ba73">GenerateOffsets</a> (MPI_Comm comm, int local_size, mfem::Array&lt; HYPRE_Int &gt; &amp;offsets)</td></tr>
<tr class="memdesc:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs Single case. <br/></td></tr>
<tr class="separator:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a700414304bda429eed073858c70107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a700414304bda429eed073858c70107"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3a700414304bda429eed073858c70107">InnerProduct</a> (const mfem::Vector &amp;weight, const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3a700414304bda429eed073858c70107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a3a700414304bda429eed073858c70107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c164d11d16e6049109e7bc2083cfe24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c164d11d16e6049109e7bc2083cfe24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6c164d11d16e6049109e7bc2083cfe24">InnerProduct</a> (const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a6c164d11d16e6049109e7bc2083cfe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the usual l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a6c164d11d16e6049109e7bc2083cfe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9316676ba86a92240eb3cbcfe2a4beba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9316676ba86a92240eb3cbcfe2a4beba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Partition</b> (const mfem::SparseMatrix &amp;w_table, mfem::Array&lt; int &gt; &amp;partitioning, int num_parts)</td></tr>
<tr class="separator:a9316676ba86a92240eb3cbcfe2a4beba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af8bece0841226866214c4ae81c8e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4af8bece0841226866214c4ae81c8e08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4af8bece0841226866214c4ae81c8e08">VisualizeSolution</a> (int k, mfem::ParFiniteElementSpace *sigmafespace, mfem::ParFiniteElementSpace *ufespace, const mfem::SparseMatrix &amp;D, const mfem::BlockVector &amp;sol)</td></tr>
<tr class="memdesc:a4af8bece0841226866214c4ae81c8e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use GLVis to visualize finite volume solution. <br/></td></tr>
<tr class="separator:a4af8bece0841226866214c4ae81c8e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6c84f477a604527bbcadbfed9d38e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aa6c84f477a604527bbcadbfed9d38e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PostProcess</b> (mfem::SparseMatrix &amp;M_global, mfem::SparseMatrix &amp;D_global, <a class="el" href="classsmoothg_1_1GraphTopology.html">GraphTopology</a> &amp;graph_topology_, mfem::Vector &amp;sol, mfem::Vector &amp;solp, const mfem::Vector &amp;rhs)</td></tr>
<tr class="separator:a1aa6c84f477a604527bbcadbfed9d38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07e3540f008ab670e20be6373e152b"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#adc07e3540f008ab670e20be6373e152b">GenerateBoundaryAttributeTable</a> (const mfem::Mesh *mesh)</td></tr>
<tr class="memdesc:adc07e3540f008ab670e20be6373e152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build boundary attribute table from mesh.  <a href="#adc07e3540f008ab670e20be6373e152b">More...</a><br/></td></tr>
<tr class="separator:adc07e3540f008ab670e20be6373e152b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6227fc30ba428ab9d49ac84b28d6dcb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6227fc30ba428ab9d49ac84b28d6dcb3">MarkDofsOnBoundary</a> (const mfem::SparseMatrix &amp;face_boundaryatt, const mfem::SparseMatrix &amp;face_dof, const mfem::Array&lt; int &gt; &amp;bndrAttributesMarker, mfem::Array&lt; int &gt; &amp;dofMarker)</td></tr>
<tr class="separator:a6227fc30ba428ab9d49ac84b28d6dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314172fc52915b9835aba5825b33f28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a314172fc52915b9835aba5825b33f28f">GetTableRow</a> (const mfem::SparseMatrix &amp;mat, int rownum, mfem::Array&lt; int &gt; &amp;J)</td></tr>
<tr class="memdesc:a314172fc52915b9835aba5825b33f28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treat a SparseMatrix as a (boolean) table, and return the column indices of a given row in the Array J.  <a href="#a314172fc52915b9835aba5825b33f28f">More...</a><br/></td></tr>
<tr class="separator:a314172fc52915b9835aba5825b33f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0196b945970d7f1d40dd91d8208ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a62c0196b945970d7f1d40dd91d8208ea">ReadVertexEdge</a> (std::ifstream &amp;graphFile, mfem::SparseMatrix &amp;out)</td></tr>
<tr class="memdesc:a62c0196b945970d7f1d40dd91d8208ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a graph from a file.  <a href="#a62c0196b945970d7f1d40dd91d8208ea">More...</a><br/></td></tr>
<tr class="separator:a62c0196b945970d7f1d40dd91d8208ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70effb0407e0cd4ef19651bf6878f3b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70effb0407e0cd4ef19651bf6878f3b0"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><b>ReadVertexEdge</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:a70effb0407e0cd4ef19651bf6878f3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4314df7735dac565a5b6680e500d9cc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4314df7735dac565a5b6680e500d9cc9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReadCoordinate</b> (std::ifstream &amp;graphFile, mfem::SparseMatrix &amp;out)</td></tr>
<tr class="separator:a4314df7735dac565a5b6680e500d9cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595ceff33e6f4a6a8008f5c58db657af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a595ceff33e6f4a6a8008f5c58db657af"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>DivError</b> (MPI_Comm comm, const mfem::SparseMatrix &amp;D, const mfem::Vector &amp;numer, const mfem::Vector &amp;denom)</td></tr>
<tr class="separator:a595ceff33e6f4a6a8008f5c58db657af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6011aec7dfd9841affc41722254723"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e6011aec7dfd9841affc41722254723"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>CompareError</b> (MPI_Comm comm, const mfem::Vector &amp;numer, const mfem::Vector &amp;denom)</td></tr>
<tr class="separator:a7e6011aec7dfd9841affc41722254723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a678f14743a8d2d9106a917688dc87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3a678f14743a8d2d9106a917688dc87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ShowErrors</b> (const std::vector&lt; double &gt; &amp;error_info, std::ostream &amp;out, bool pretty)</td></tr>
<tr class="separator:ae3a678f14743a8d2d9106a917688dc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d646143475c95cec019eaecf5dfc877"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4d646143475c95cec019eaecf5dfc877">ComputeErrors</a> (MPI_Comm comm, const mfem::SparseMatrix &amp;M, const mfem::SparseMatrix &amp;D, const mfem::BlockVector &amp;upscaled_sol, const mfem::BlockVector &amp;fine_sol)</td></tr>
<tr class="separator:a4d646143475c95cec019eaecf5dfc877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd62db02f43f795aa63150b83ae954e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd62db02f43f795aa63150b83ae954e3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#acd62db02f43f795aa63150b83ae954e3">PowerIterate</a> (MPI_Comm comm, const mfem::Operator &amp;A, mfem::Vector &amp;result, int max_iter=1000, double tol=1e-8, bool verbose=false)</td></tr>
<tr class="memdesc:acd62db02f43f795aa63150b83ae954e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use power iterations to find the maximum eigenpair. <br/></td></tr>
<tr class="separator:acd62db02f43f795aa63150b83ae954e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The overall namespace for the smoothG project. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4d646143475c95cec019eaecf5dfc877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; smoothg::ComputeErrors </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::BlockVector &amp;&#160;</td>
          <td class="paramname"><em>upscaled_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::BlockVector &amp;&#160;</td>
          <td class="paramname"><em>fine_sol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare errors between upscaled and fine solution. Returns {vertex_error, edge_error, div_error} array. </p>

</div>
</div>
<a class="anchor" id="a3393af3ae95d1a28009e2784476ba92c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::Deflate </td>
          <td>(</td>
          <td class="paramtype">mfem::DenseMatrix &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make all column vectors of a orthogonal to v. </p>
<p>The input vector v is assumed to be a unit vector </p>

</div>
</div>
<a class="anchor" id="af14519b1c256224b0cc87002eded8c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::SparseMatrix smoothg::ExtractRowAndColumns </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>colMapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>colMapper_not_filled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a submatrix from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix to extract from </td></tr>
    <tr><td class="paramname">rows</td><td>the rows to extract </td></tr>
    <tr><td class="paramname">cols</td><td>the columns to extract </td></tr>
    <tr><td class="paramname">colMapper</td><td>basically a data workspace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extracted submatrix </dd></dl>

</div>
</div>
<a class="anchor" id="ad4246dcf5055f29128164b2ad25c0f76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::ExtractSubMatrix </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>colMapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::DenseMatrix &amp;&#160;</td>
          <td class="paramname"><em>A_sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a submatrix from a sparse matrix, return it dense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix to extract from </td></tr>
    <tr><td class="paramname">rows</td><td>the rows to extract </td></tr>
    <tr><td class="paramname">cols</td><td>the columns to extract </td></tr>
    <tr><td class="paramname">colMapper</td><td>basically a data workspace </td></tr>
    <tr><td class="paramname">A_sub</td><td>the returned (dense) submatrix) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e9d52f60e116a5026a1992b62dfe0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::Full </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>Asparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::DenseMatrix &amp;&#160;</td>
          <td class="paramname"><em>Adense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a DenseMatrix with the entries of a SparseMatrix. </p>
<p>The size of the matrix Adense is set to be same as the size of Asparse </p>

</div>
</div>
<a class="anchor" id="a7d1e6bee3cd75b7885d7b69ae5b5526f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::FullTranspose </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>Asparse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::DenseMatrix &amp;&#160;</td>
          <td class="paramname"><em>AdenseT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill a DenseMatrix with the entries of transpose of a SparseMatrix. </p>
<p>The size of the matrix AdenseT is set to be same as the size of Asparse^T </p>

</div>
</div>
<a class="anchor" id="adc07e3540f008ab670e20be6373e152b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::SparseMatrix smoothg::GenerateBoundaryAttributeTable </td>
          <td>(</td>
          <td class="paramtype">const mfem::Mesh *&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build boundary attribute table from mesh. </p>
<p>Construct edge to boundary attribute table (orientation is not considered)</p>
<p>Copied from parelag::AgglomeratedTopology::generateFacetBdrAttributeTable</p>
<p>Given a mesh and a boundary operator B[0], with height number of elements, width number of faces, this computes a table with a row for every face and a column for every boundary attribute, with a 1 if the face has that boundary attribute.</p>
<p>This only works for the fine level, because of the mfem::Mesh. To get this table on a coarser mesh, premultiply by AEntity_entity. </p>

</div>
</div>
<a class="anchor" id="a2d80d522d87be6998895981663dcb336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; mfem::Vector &gt; smoothg::get_blocks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; mfem::BlockVector &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>blockvecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>block_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a std::vector of mfem::Vectors from a std::vector of mfem::BlockVectors</p>
<p>Given a block number, pulls out the mfem::Vectors from each BlockVector associated with that block number and puts it into a std::vector. Each mfem::Vector is only a view, so this does not do a deep copy. </p>

</div>
</div>
<a class="anchor" id="a7b7f3460c5e52ae27462a9a81a1495df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::DenseMatrix smoothg::get_sq_differences_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; mfem::Vector &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::SparseMatrix *&#160;</td>
          <td class="paramname"><em>inner_prod_mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>diag_sq_norms</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a matrix of squared errors.</p>
<p>Produces a strictly lower triangular matrix of squared differences between vectors under the given inner-product norm. If diag_sq_norms, the diagonal contains the squared norms of the vectors in the inner-product norm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>The std::vector of mfem::Vectors to compare. </td></tr>
    <tr><td class="paramname">inner_prod_mats</td><td>The inner product matrix defining the norm to use. </td></tr>
    <tr><td class="paramname">diag_sq_norms</td><td>If true, put the squared norms of the vectors on the diagonal. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a314172fc52915b9835aba5825b33f28f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::GetTableRow </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rownum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Treat a SparseMatrix as a (boolean) table, and return the column indices of a given row in the Array J. </p>
<p>This implementation basically taken from DofAgglomeration::GetViewAgglomerateDofGlobalNumbering() as one step to extracting from Parelag.</p>
<p>This is normally used with a mat that corresponds to some entity_dof or related table. </p>

</div>
</div>
<a class="anchor" id="a6227fc30ba428ab9d49ac84b28d6dcb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smoothg::MarkDofsOnBoundary </td>
          <td>(</td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>face_boundaryatt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>face_dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bndrAttributesMarker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::Array&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dofMarker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a face_boundaryatrribute matrix, bndrAttributesMarker, and face_dof, fill dofMarker so that it can be used for MFEM elimination routines to enforce boundary conditions.</p>
<p>Stolen from parelag::DofHandlerALG::MarkDofsOnSelectedBndr </p>

</div>
</div>
<a class="anchor" id="af48002c1039dcb0c8301b45364394c9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double smoothg::MaxNorm </td>
          <td>(</td>
          <td class="paramtype">const mfem::HypreParMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute max norm of parallel matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Parallel Matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78aa208a6e56502beb7962055df7684e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::Mult_a_VVt </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::DenseMatrix &amp;&#160;</td>
          <td class="paramname"><em>aVVt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (scaled) outer product <img class="formulaInl" alt="$ a v v^T $" src="form_17.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>scalar multiple </td></tr>
    <tr><td class="paramname">v</td><td>the vector to outer product. </td></tr>
    <tr><td class="paramname">aVVt</td><td>the returned dense matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee8776e75d8f97d83b52ad0e3fed8f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::orthogonalize_from_constant </td>
          <td>(</td>
          <td class="paramtype">mfem::Vector &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalize this vector from the constant vector. </p>
<p>This is equivalent to shifting the vector so it has zero mean.</p>
<p>The correct way to do this is with respect to a finite element space, take an FiniteElementSpace argument or a list of volumes or something. For now we assume equal size volumes, or a graph, and just take vec.Sum() / vec.Size()</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>improve this for the finite volume case </dd></dl>

</div>
</div>
<a class="anchor" id="a2bcfe4bfbd5b1cc452acd5139b512b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::par_orthogonalize_from_constant </td>
          <td>(</td>
          <td class="paramtype">mfem::Vector &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>globalsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalize this vector from the constant vector. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>MPI_COMM_WORLD should be more generic </dd></dl>
<p>This is equivalent to shifting the vector so it has zero mean.</p>
<p>The correct way to do this is with respect to a finite element space, take an FiniteElementSpace argument or a list of volumes or something. For now we assume equal size volumes, or a graph, and just take vec.Sum() / vec.Size()</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>improve this for the finite volume case </dd></dl>

</div>
</div>
<a class="anchor" id="a122311dc2c2578bd483a89334938cfad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::HypreParMatrix * smoothg::ParAdd </td>
          <td>(</td>
          <td class="paramtype">const mfem::HypreParMatrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mfem::HypreParMatrix &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two parallel matrices C = A + B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>left hand side matrix </td></tr>
    <tr><td class="paramname">B</td><td>right hand side matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>can be removed with MFEM version &gt; 3.3.2 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2generalgraph_8cpp-example.html#a15">examples/generalgraph.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a62c0196b945970d7f1d40dd91d8208ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smoothg::ReadVertexEdge </td>
          <td>(</td>
          <td class="paramtype">std::ifstream &amp;&#160;</td>
          <td class="paramname"><em>graphFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mfem::SparseMatrix &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a graph from a file. </p>
<p>The graph is represented as a vertex_edge table.</p>
<p>The format is a text-based CSR format:</p>
<ul>
<li>number of vertices</li>
<li>number of edges</li>
<li>I array</li>
<li>J array</li>
<li>data array</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphFile</td><td>the (open) stream to read </td></tr>
    <tr><td class="paramname">out</td><td>a reference to the returned matrix </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="examples_2generalgraph_8cpp-example.html#a3">examples/generalgraph.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="afc66645634ac5a0d2bbac57b2abe508c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::SparseMatrix smoothg::SparseIdentity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an rectangular identity matrix (as a SparseMatrix) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>number of row </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns  row_offset offset row where diagonal identity starts  col_offset offset column where diagonal identity starts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf1c72e21539d2be5cbe3bb039faf9ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mfem::SparseMatrix smoothg::VectorToMatrix </td>
          <td>(</td>
          <td class="paramtype">const mfem::Vector &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a diagonal matrix with the entries specified by a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>diagonal entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
