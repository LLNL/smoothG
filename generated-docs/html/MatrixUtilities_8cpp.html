<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>smoothG: src/MatrixUtilities.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="smoothg_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">smoothG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixUtilities.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementations of some utility routines for linear algebra.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="MatrixUtilities_8hpp.html">MatrixUtilities.hpp</a>&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="utilities_8hpp.html">utilities.hpp</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesmoothg"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html">smoothg</a></td></tr>
<tr class="memdesc:namespacesmoothg"><td class="mdescLeft">&#160;</td><td class="mdescRight">The overall namespace for the smoothG project. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fb8c426c39e89c98b4be6981f701b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad9fb8c426c39e89c98b4be6981f701b6">smoothg::Print</a> (const mfem::DenseMatrix &amp;mat, const std::string &amp;label=&quot;&quot;, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:ad9fb8c426c39e89c98b4be6981f701b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dense matrices. <br/></td></tr>
<tr class="separator:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94e9c24a58278f441192080533ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd94e9c24a58278f441192080533ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::Print</b> (const mfem::SparseMatrix &amp;mat, const std::string &amp;label, std::ostream &amp;out)</td></tr>
<tr class="separator:aafd94e9c24a58278f441192080533ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0eacbfc58943662b27572af61d4391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b0eacbfc58943662b27572af61d4391"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4b0eacbfc58943662b27572af61d4391">smoothg::Transpose</a> (const mfem::SparseMatrix &amp;A)</td></tr>
<tr class="memdesc:a4b0eacbfc58943662b27572af61d4391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transpose of a matrix. <br/></td></tr>
<tr class="separator:a4b0eacbfc58943662b27572af61d4391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f21a9a7d1292763ed8d1343ba02ddc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a73f21a9a7d1292763ed8d1343ba02ddc">smoothg::Mult</a> (const mfem::SparseMatrix &amp;A, const mfem::SparseMatrix &amp;B)</td></tr>
<tr class="memdesc:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two sparse matrices C = A * B. <br/></td></tr>
<tr class="separator:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad122480ce3940768078a156f33296211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad122480ce3940768078a156f33296211"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad122480ce3940768078a156f33296211">smoothg::Threshold</a> (const mfem::SparseMatrix &amp;mat, double tol=1e-8)</td></tr>
<tr class="memdesc:ad122480ce3940768078a156f33296211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove small entries from a matrix. <br/></td></tr>
<tr class="separator:ad122480ce3940768078a156f33296211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ed67c6b7549e2d5d5c77f5f15fd4641"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4ed67c6b7549e2d5d5c77f5f15fd4641">smoothg::TableToSparse</a> (const mfem::Table &amp;table)</td></tr>
<tr class="memdesc:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sparse matrix from a table. <br/></td></tr>
<tr class="separator:a4ed67c6b7549e2d5d5c77f5f15fd4641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546d3176c315dd1dd67271f9a80a937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af546d3176c315dd1dd67271f9a80a937"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::RAP</b> (const mfem::HypreParMatrix &amp;R, const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:af546d3176c315dd1dd67271f9a80a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95fe015f108f8913febf1d7045c6893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa95fe015f108f8913febf1d7045c6893"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::RAP</b> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:aa95fe015f108f8913febf1d7045c6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8af82a4c75783a1c00e4a262b299bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8e8af82a4c75783a1c00e4a262b299bb">smoothg::BroadCast</a> (MPI_Comm comm, mfem::SparseMatrix &amp;mat)</td></tr>
<tr class="memdesc:a8e8af82a4c75783a1c00e4a262b299bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a SparseMatrix on processor 0 to all other processors. <br/></td></tr>
<tr class="separator:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462c47e554826e19abcf3f9e42f277c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8462c47e554826e19abcf3f9e42f277c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8462c47e554826e19abcf3f9e42f277c">smoothg::MultSparseDense</a> (const mfem::SparseMatrix &amp;A, mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a8462c47e554826e19abcf3f9e42f277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense. <br/></td></tr>
<tr class="separator:a8462c47e554826e19abcf3f9e42f277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24b00fa9f7f31b0d18a12ce09fca656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ac24b00fa9f7f31b0d18a12ce09fca656">smoothg::MultSparseDenseTranspose</a> (const mfem::SparseMatrix &amp;A, mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense, but C is kept transposed. <br/></td></tr>
<tr class="separator:ac24b00fa9f7f31b0d18a12ce09fca656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa208a6e56502beb7962055df7684e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a78aa208a6e56502beb7962055df7684e">smoothg::Mult_a_VVt</a> (const double a, const mfem::Vector &amp;v, mfem::DenseMatrix &amp;aVVt)</td></tr>
<tr class="memdesc:a78aa208a6e56502beb7962055df7684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (scaled) outer product <img class="formulaInl" alt="$ a v v^T $" src="form_17.png"/>.  <a href="#a78aa208a6e56502beb7962055df7684e">More...</a><br/></td></tr>
<tr class="separator:a78aa208a6e56502beb7962055df7684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac15dbc5f2d35bc991c4240be40e38a99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ac15dbc5f2d35bc991c4240be40e38a99">smoothg::SetConstantValue</a> (mfem::HypreParMatrix &amp;pmat, double c)</td></tr>
<tr class="memdesc:ac15dbc5f2d35bc991c4240be40e38a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values of the non zero entries of a HypreParMatrix to 'c'. <br/></td></tr>
<tr class="separator:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c3bcb3238d0d372b1459370b642dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87c3bcb3238d0d372b1459370b642dc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ae87c3bcb3238d0d372b1459370b642dc">smoothg::PartitionToMatrix</a> (const mfem::Array&lt; int &gt; &amp;partition, int nparts)</td></tr>
<tr class="memdesc:ae87c3bcb3238d0d372b1459370b642dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the relation table aggregate to vertex from partition. <br/></td></tr>
<tr class="separator:ae87c3bcb3238d0d372b1459370b642dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5681811902cac31df51a44d9c57e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5681811902cac31df51a44d9c57e1d"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afb5681811902cac31df51a44d9c57e1d">smoothg::SparseIdentity</a> (int size)</td></tr>
<tr class="memdesc:afb5681811902cac31df51a44d9c57e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an identity matrix (as a SparseMatrix) of size 'size'. <br/></td></tr>
<tr class="separator:afb5681811902cac31df51a44d9c57e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc66645634ac5a0d2bbac57b2abe508c"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afc66645634ac5a0d2bbac57b2abe508c">smoothg::SparseIdentity</a> (int rows, int cols, int row_offset=0, int col_offset=0)</td></tr>
<tr class="memdesc:afc66645634ac5a0d2bbac57b2abe508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an rectangular identity matrix (as a SparseMatrix)  <a href="#afc66645634ac5a0d2bbac57b2abe508c">More...</a><br/></td></tr>
<tr class="separator:afc66645634ac5a0d2bbac57b2abe508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#adf1c72e21539d2be5cbe3bb039faf9ce">smoothg::VectorToMatrix</a> (const mfem::Vector &amp;vect)</td></tr>
<tr class="memdesc:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a diagonal matrix with the entries specified by a vector.  <a href="#adf1c72e21539d2be5cbe3bb039faf9ce">More...</a><br/></td></tr>
<tr class="separator:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122311dc2c2578bd483a89334938cfad"><td class="memItemLeft" align="right" valign="top">mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a122311dc2c2578bd483a89334938cfad">smoothg::ParAdd</a> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;B)</td></tr>
<tr class="memdesc:a122311dc2c2578bd483a89334938cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two parallel matrices C = A + B.  <a href="#a122311dc2c2578bd483a89334938cfad">More...</a><br/></td></tr>
<tr class="separator:a122311dc2c2578bd483a89334938cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48002c1039dcb0c8301b45364394c9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af48002c1039dcb0c8301b45364394c9c">smoothg::MaxNorm</a> (const mfem::HypreParMatrix &amp;A)</td></tr>
<tr class="memdesc:af48002c1039dcb0c8301b45364394c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute max norm of parallel matrix.  <a href="#af48002c1039dcb0c8301b45364394c9c">More...</a><br/></td></tr>
<tr class="separator:af48002c1039dcb0c8301b45364394c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14519b1c256224b0cc87002eded8c23"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af14519b1c256224b0cc87002eded8c23">smoothg::ExtractRowAndColumns</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, mfem::Array&lt; int &gt; &amp;colMapper, bool colMapper_not_filled=true)</td></tr>
<tr class="memdesc:af14519b1c256224b0cc87002eded8c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a matrix.  <a href="#af14519b1c256224b0cc87002eded8c23">More...</a><br/></td></tr>
<tr class="separator:af14519b1c256224b0cc87002eded8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4246dcf5055f29128164b2ad25c0f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad4246dcf5055f29128164b2ad25c0f76">smoothg::ExtractSubMatrix</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, const mfem::Array&lt; int &gt; &amp;colMapper, mfem::DenseMatrix &amp;A_sub)</td></tr>
<tr class="memdesc:ad4246dcf5055f29128164b2ad25c0f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a sparse matrix, return it dense.  <a href="#ad4246dcf5055f29128164b2ad25c0f76">More...</a><br/></td></tr>
<tr class="separator:ad4246dcf5055f29128164b2ad25c0f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a5e9d52f60e116a5026a1992b62dfe0cc">smoothg::Full</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;Adense)</td></tr>
<tr class="memdesc:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of a SparseMatrix.  <a href="#a5e9d52f60e116a5026a1992b62dfe0cc">More...</a><br/></td></tr>
<tr class="separator:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7d1e6bee3cd75b7885d7b69ae5b5526f">smoothg::FullTranspose</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;AdenseT)</td></tr>
<tr class="memdesc:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of transpose of a SparseMatrix.  <a href="#a7d1e6bee3cd75b7885d7b69ae5b5526f">More...</a><br/></td></tr>
<tr class="separator:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264079f7cc4cecd453569a1c0354ad3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2264079f7cc4cecd453569a1c0354ad3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2264079f7cc4cecd453569a1c0354ad3">smoothg::Concatenate</a> (const mfem::Vector &amp;a, const mfem::DenseMatrix &amp;b, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a2264079f7cc4cecd453569a1c0354ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend the (column) vector a to the matrix b. <br/></td></tr>
<tr class="separator:a2264079f7cc4cecd453569a1c0354ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3393af3ae95d1a28009e2784476ba92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3393af3ae95d1a28009e2784476ba92c">smoothg::Deflate</a> (mfem::DenseMatrix &amp;a, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3393af3ae95d1a28009e2784476ba92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all column vectors of a orthogonal to v.  <a href="#a3393af3ae95d1a28009e2784476ba92c">More...</a><br/></td></tr>
<tr class="separator:a3393af3ae95d1a28009e2784476ba92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#aee8776e75d8f97d83b52ad0e3fed8f88">smoothg::orthogonalize_from_constant</a> (mfem::Vector &amp;vec)</td></tr>
<tr class="memdesc:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector from the constant vector.  <a href="#aee8776e75d8f97d83b52ad0e3fed8f88">More...</a><br/></td></tr>
<tr class="separator:aee8776e75d8f97d83b52ad0e3fed8f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2bcfe4bfbd5b1cc452acd5139b512b1b">smoothg::par_orthogonalize_from_constant</a> (mfem::Vector &amp;vec, int globalsize)</td></tr>
<tr class="memdesc:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector from the constant vector.  <a href="#a2bcfe4bfbd5b1cc452acd5139b512b1b">More...</a><br/></td></tr>
<tr class="separator:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad61b4c310f8bb76f5524294d46b8ce4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::par_orthogonalize_from_constant</b> (mfem::HypreParVector &amp;vec)</td></tr>
<tr class="separator:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d80d522d87be6998895981663dcb336"><td class="memItemLeft" align="right" valign="top">std::vector&lt; mfem::Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2d80d522d87be6998895981663dcb336">smoothg::get_blocks</a> (const std::vector&lt; std::unique_ptr&lt; mfem::BlockVector &gt;&gt; &amp;blockvecs, int block_num)</td></tr>
<tr class="separator:a2d80d522d87be6998895981663dcb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memItemLeft" align="right" valign="top">mfem::DenseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7b7f3460c5e52ae27462a9a81a1495df">smoothg::get_sq_differences_matrix</a> (const std::vector&lt; mfem::Vector &gt; &amp;vecs, const mfem::SparseMatrix *inner_prod_mat, bool diag_sq_norms)</td></tr>
<tr class="separator:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b97167d68e040b91c3c8eba672c67e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b97167d68e040b91c3c8eba672c67e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6b97167d68e040b91c3c8eba672c67e9">smoothg::GenerateOffsets</a> (MPI_Comm comm, int N, HYPRE_Int loc_sizes[], mfem::Array&lt; HYPRE_Int &gt; *offsets[])</td></tr>
<tr class="memdesc:a6b97167d68e040b91c3c8eba672c67e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs. <br/></td></tr>
<tr class="separator:a6b97167d68e040b91c3c8eba672c67e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72242e6f25ceaa18cdce6ca81c41ba73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a72242e6f25ceaa18cdce6ca81c41ba73">smoothg::GenerateOffsets</a> (MPI_Comm comm, int local_size, mfem::Array&lt; HYPRE_Int &gt; &amp;offsets)</td></tr>
<tr class="memdesc:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs Single case. <br/></td></tr>
<tr class="separator:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a700414304bda429eed073858c70107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a700414304bda429eed073858c70107"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3a700414304bda429eed073858c70107">smoothg::InnerProduct</a> (const mfem::Vector &amp;weight, const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3a700414304bda429eed073858c70107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a3a700414304bda429eed073858c70107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c164d11d16e6049109e7bc2083cfe24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c164d11d16e6049109e7bc2083cfe24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6c164d11d16e6049109e7bc2083cfe24">smoothg::InnerProduct</a> (const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a6c164d11d16e6049109e7bc2083cfe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the usual l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a6c164d11d16e6049109e7bc2083cfe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementations of some utility routines for linear algebra. </p>
<p>These are implemented with and operate on MFEM data structures. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
