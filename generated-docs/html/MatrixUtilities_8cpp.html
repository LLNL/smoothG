<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>smoothG: src/MatrixUtilities.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="smoothg_logo_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">smoothG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixUtilities.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementations of some utility routines for linear algebra.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="MatrixUtilities_8hpp.html">MatrixUtilities.hpp</a>&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="utilities_8hpp.html">utilities.hpp</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesmoothg"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html">smoothg</a></td></tr>
<tr class="memdesc:namespacesmoothg"><td class="mdescLeft">&#160;</td><td class="mdescRight">The overall namespace for the smoothG project. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9fb8c426c39e89c98b4be6981f701b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad9fb8c426c39e89c98b4be6981f701b6">smoothg::Print</a> (const mfem::DenseMatrix &amp;mat, const std::string &amp;label=&quot;&quot;, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:ad9fb8c426c39e89c98b4be6981f701b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dense matrices. <br/></td></tr>
<tr class="separator:ad9fb8c426c39e89c98b4be6981f701b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd94e9c24a58278f441192080533ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd94e9c24a58278f441192080533ff5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::Print</b> (const mfem::SparseMatrix &amp;mat, const std::string &amp;label, std::ostream &amp;out)</td></tr>
<tr class="separator:aafd94e9c24a58278f441192080533ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0eacbfc58943662b27572af61d4391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b0eacbfc58943662b27572af61d4391"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4b0eacbfc58943662b27572af61d4391">smoothg::Transpose</a> (const mfem::SparseMatrix &amp;A)</td></tr>
<tr class="memdesc:a4b0eacbfc58943662b27572af61d4391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute transpose of a matrix. <br/></td></tr>
<tr class="separator:a4b0eacbfc58943662b27572af61d4391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f21a9a7d1292763ed8d1343ba02ddc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a73f21a9a7d1292763ed8d1343ba02ddc">smoothg::Mult</a> (const mfem::SparseMatrix &amp;A, const mfem::SparseMatrix &amp;B)</td></tr>
<tr class="memdesc:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two sparse matrices C = A * B. <br/></td></tr>
<tr class="separator:a73f21a9a7d1292763ed8d1343ba02ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6698bbd0da58ff31a495b57c64c63b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b6698bbd0da58ff31a495b57c64c63b"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a0b6698bbd0da58ff31a495b57c64c63b">smoothg::AAt</a> (const mfem::SparseMatrix &amp;A)</td></tr>
<tr class="memdesc:a0b6698bbd0da58ff31a495b57c64c63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product A * A^T. <br/></td></tr>
<tr class="separator:a0b6698bbd0da58ff31a495b57c64c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0875da8a2bb1a2868a138298c06cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada0875da8a2bb1a2868a138298c06cae"></a>
std::unique_ptr<br class="typebreak"/>
&lt; mfem::HypreParMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::AAt</b> (const mfem::HypreParMatrix &amp;A)</td></tr>
<tr class="separator:ada0875da8a2bb1a2868a138298c06cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fbcc3b1ec99b26e83deffe8f99685"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; mfem::HypreParMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a343fbcc3b1ec99b26e83deffe8f99685">smoothg::ParMult</a> (const mfem::HypreParMatrix &amp;A, const mfem::SparseMatrix &amp;B, const mfem::Array&lt; int &gt; &amp;B_colpart)</td></tr>
<tr class="memdesc:a343fbcc3b1ec99b26e83deffe8f99685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product A * B between HypreParMatrix and SparseMatrix.  <a href="#a343fbcc3b1ec99b26e83deffe8f99685">More...</a><br/></td></tr>
<tr class="separator:a343fbcc3b1ec99b26e83deffe8f99685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51928e06ed6bca70bd83e6fe38f9b7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; mfem::HypreParMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7a51928e06ed6bca70bd83e6fe38f9b7">smoothg::ParMult</a> (const mfem::SparseMatrix &amp;A, const mfem::HypreParMatrix &amp;B, const mfem::Array&lt; int &gt; &amp;A_rowpart)</td></tr>
<tr class="memdesc:a7a51928e06ed6bca70bd83e6fe38f9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product A * B between SparseMatrix and HypreParMatrix.  <a href="#a7a51928e06ed6bca70bd83e6fe38f9b7">More...</a><br/></td></tr>
<tr class="separator:a7a51928e06ed6bca70bd83e6fe38f9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b8291c2e0db93801eafa6218948b2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88b8291c2e0db93801eafa6218948b2c"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a88b8291c2e0db93801eafa6218948b2c">smoothg::DropSmall</a> (const mfem::SparseMatrix &amp;mat, double tol=1e-8)</td></tr>
<tr class="memdesc:a88b8291c2e0db93801eafa6218948b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove small entries (absolute value &lt; tol) from a matrix. <br/></td></tr>
<tr class="separator:a88b8291c2e0db93801eafa6218948b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add43bdd4aa98bb96cd2f2e66064f2449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add43bdd4aa98bb96cd2f2e66064f2449"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#add43bdd4aa98bb96cd2f2e66064f2449">smoothg::TableToMatrix</a> (const mfem::Table &amp;table)</td></tr>
<tr class="memdesc:add43bdd4aa98bb96cd2f2e66064f2449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sparse matrix from a table. <br/></td></tr>
<tr class="separator:add43bdd4aa98bb96cd2f2e66064f2449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d2fde67c0080b6ef2f0bef3c89efa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d2fde67c0080b6ef2f0bef3c89efa2"></a>
mfem::Table&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a37d2fde67c0080b6ef2f0bef3c89efa2">smoothg::MatrixToTable</a> (const mfem::SparseMatrix &amp;mat)</td></tr>
<tr class="memdesc:a37d2fde67c0080b6ef2f0bef3c89efa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table from a sparse matrix's graph. <br/></td></tr>
<tr class="separator:a37d2fde67c0080b6ef2f0bef3c89efa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4fd47c852263e5aa565a067e4ee968"><td class="memItemLeft" align="right" valign="top">mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8e4fd47c852263e5aa565a067e4ee968">smoothg::Mult</a> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;B, const mfem::HypreParMatrix &amp;C)</td></tr>
<tr class="separator:a8e4fd47c852263e5aa565a067e4ee968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546d3176c315dd1dd67271f9a80a937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af546d3176c315dd1dd67271f9a80a937"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::RAP</b> (const mfem::HypreParMatrix &amp;R, const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:af546d3176c315dd1dd67271f9a80a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95fe015f108f8913febf1d7045c6893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa95fe015f108f8913febf1d7045c6893"></a>
mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::RAP</b> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;P)</td></tr>
<tr class="separator:aa95fe015f108f8913febf1d7045c6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8af82a4c75783a1c00e4a262b299bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a8e8af82a4c75783a1c00e4a262b299bb">smoothg::BroadCast</a> (MPI_Comm comm, mfem::SparseMatrix &amp;mat)</td></tr>
<tr class="memdesc:a8e8af82a4c75783a1c00e4a262b299bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a SparseMatrix on processor 0 to all other processors. <br/></td></tr>
<tr class="separator:a8e8af82a4c75783a1c00e4a262b299bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8654cf467d03ca6a8604e11e47fe27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf8654cf467d03ca6a8604e11e47fe27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#aaf8654cf467d03ca6a8604e11e47fe27">smoothg::MultSparseDense</a> (const mfem::SparseMatrix &amp;A, const mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:aaf8654cf467d03ca6a8604e11e47fe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense. <br/></td></tr>
<tr class="separator:aaf8654cf467d03ca6a8604e11e47fe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e069b55bc0cef2368c950f7d180498"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e069b55bc0cef2368c950f7d180498"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a35e069b55bc0cef2368c950f7d180498">smoothg::MultSparseDenseTranspose</a> (const mfem::SparseMatrix &amp;A, const mfem::DenseMatrix &amp;B, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a35e069b55bc0cef2368c950f7d180498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$ C = AB $" src="form_15.png"/>, where <img class="formulaInl" alt="$ A $" src="form_0.png"/> is sparse and <img class="formulaInl" alt="$ B $" src="form_16.png"/> is dense, but C is kept transposed. <br/></td></tr>
<tr class="separator:a35e069b55bc0cef2368c950f7d180498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78aa208a6e56502beb7962055df7684e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a78aa208a6e56502beb7962055df7684e">smoothg::Mult_a_VVt</a> (const double a, const mfem::Vector &amp;v, mfem::DenseMatrix &amp;aVVt)</td></tr>
<tr class="memdesc:a78aa208a6e56502beb7962055df7684e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (scaled) outer product <img class="formulaInl" alt="$ a v v^T $" src="form_17.png"/>.  <a href="#a78aa208a6e56502beb7962055df7684e">More...</a><br/></td></tr>
<tr class="separator:a78aa208a6e56502beb7962055df7684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac15dbc5f2d35bc991c4240be40e38a99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ac15dbc5f2d35bc991c4240be40e38a99">smoothg::SetConstantValue</a> (mfem::HypreParMatrix &amp;pmat, double c)</td></tr>
<tr class="memdesc:ac15dbc5f2d35bc991c4240be40e38a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set values of the non zero entries of a HypreParMatrix to 'c'. <br/></td></tr>
<tr class="separator:ac15dbc5f2d35bc991c4240be40e38a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87c3bcb3238d0d372b1459370b642dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87c3bcb3238d0d372b1459370b642dc"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ae87c3bcb3238d0d372b1459370b642dc">smoothg::PartitionToMatrix</a> (const mfem::Array&lt; int &gt; &amp;partition, int nparts)</td></tr>
<tr class="memdesc:ae87c3bcb3238d0d372b1459370b642dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the relation table aggregate to vertex from partition. <br/></td></tr>
<tr class="separator:ae87c3bcb3238d0d372b1459370b642dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5681811902cac31df51a44d9c57e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5681811902cac31df51a44d9c57e1d"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afb5681811902cac31df51a44d9c57e1d">smoothg::SparseIdentity</a> (int size)</td></tr>
<tr class="memdesc:afb5681811902cac31df51a44d9c57e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an identity matrix (as a SparseMatrix) of size 'size'. <br/></td></tr>
<tr class="separator:afb5681811902cac31df51a44d9c57e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc66645634ac5a0d2bbac57b2abe508c"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#afc66645634ac5a0d2bbac57b2abe508c">smoothg::SparseIdentity</a> (int rows, int cols, int row_offset=0, int col_offset=0)</td></tr>
<tr class="memdesc:afc66645634ac5a0d2bbac57b2abe508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an rectangular identity matrix (as a SparseMatrix)  <a href="#afc66645634ac5a0d2bbac57b2abe508c">More...</a><br/></td></tr>
<tr class="separator:afc66645634ac5a0d2bbac57b2abe508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f99a95df53cf1b71bcb351d5fb216e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7f99a95df53cf1b71bcb351d5fb216e8">smoothg::Add</a> (const double a, mfem::SparseMatrix &amp;mat, const double b, const mfem::Vector &amp;vec, const bool invert_vec=false)</td></tr>
<tr class="memdesc:a7f99a95df53cf1b71bcb351d5fb216e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">mat = a * mat + b * diag(vec) or diag(vec^{-1}) if invert_vec = true  <a href="#a7f99a95df53cf1b71bcb351d5fb216e8">More...</a><br/></td></tr>
<tr class="separator:a7f99a95df53cf1b71bcb351d5fb216e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b19055689ec01cc7577d91495139f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6b19055689ec01cc7577d91495139f8d">smoothg::Add</a> (mfem::SparseMatrix &amp;mat, const mfem::Vector &amp;vec, const bool invert_vec=false)</td></tr>
<tr class="memdesc:a6b19055689ec01cc7577d91495139f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">mat = mat + diag(vec) or diag(vec^{-1}) if invert_vec = true  <a href="#a6b19055689ec01cc7577d91495139f8d">More...</a><br/></td></tr>
<tr class="separator:a6b19055689ec01cc7577d91495139f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe251a89bd06726b8701168dae241958"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe251a89bd06726b8701168dae241958"></a>
mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#abe251a89bd06726b8701168dae241958">smoothg::Mult_AtDA</a> (const mfem::SparseMatrix &amp;A, const mfem::Vector &amp;D)</td></tr>
<tr class="memdesc:abe251a89bd06726b8701168dae241958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute A^t * diag(D) * A. <br/></td></tr>
<tr class="separator:abe251a89bd06726b8701168dae241958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#adf1c72e21539d2be5cbe3bb039faf9ce">smoothg::VectorToMatrix</a> (const mfem::Vector &amp;vect)</td></tr>
<tr class="memdesc:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a diagonal matrix with the entries specified by a vector.  <a href="#adf1c72e21539d2be5cbe3bb039faf9ce">More...</a><br/></td></tr>
<tr class="separator:adf1c72e21539d2be5cbe3bb039faf9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5cca66eb2c87ba2ce3bb59912f0abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a4b5cca66eb2c87ba2ce3bb59912f0abd">smoothg::AddScaledSubMatrix</a> (mfem::SparseMatrix &amp;mat, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, const mfem::DenseMatrix &amp;subm, double scaling, int skip_zeros)</td></tr>
<tr class="separator:a4b5cca66eb2c87ba2ce3bb59912f0abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122311dc2c2578bd483a89334938cfad"><td class="memItemLeft" align="right" valign="top">mfem::HypreParMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a122311dc2c2578bd483a89334938cfad">smoothg::ParAdd</a> (const mfem::HypreParMatrix &amp;A, const mfem::HypreParMatrix &amp;B)</td></tr>
<tr class="memdesc:a122311dc2c2578bd483a89334938cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two parallel matrices C = A + B.  <a href="#a122311dc2c2578bd483a89334938cfad">More...</a><br/></td></tr>
<tr class="separator:a122311dc2c2578bd483a89334938cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48002c1039dcb0c8301b45364394c9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af48002c1039dcb0c8301b45364394c9c">smoothg::MaxNorm</a> (const mfem::HypreParMatrix &amp;A)</td></tr>
<tr class="memdesc:af48002c1039dcb0c8301b45364394c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute max norm of parallel matrix.  <a href="#af48002c1039dcb0c8301b45364394c9c">More...</a><br/></td></tr>
<tr class="separator:af48002c1039dcb0c8301b45364394c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52878759caac720edcd0f611941323"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#aea52878759caac720edcd0f611941323">smoothg::ExtractRowAndColumns</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols)</td></tr>
<tr class="memdesc:aea52878759caac720edcd0f611941323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a matrix.  <a href="#aea52878759caac720edcd0f611941323">More...</a><br/></td></tr>
<tr class="separator:aea52878759caac720edcd0f611941323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14519b1c256224b0cc87002eded8c23"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#af14519b1c256224b0cc87002eded8c23">smoothg::ExtractRowAndColumns</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, mfem::Array&lt; int &gt; &amp;colMapper, bool colMapper_not_filled=true)</td></tr>
<tr class="memdesc:af14519b1c256224b0cc87002eded8c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a matrix.  <a href="#af14519b1c256224b0cc87002eded8c23">More...</a><br/></td></tr>
<tr class="separator:af14519b1c256224b0cc87002eded8c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4246dcf5055f29128164b2ad25c0f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ad4246dcf5055f29128164b2ad25c0f76">smoothg::ExtractSubMatrix</a> (const mfem::SparseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;rows, const mfem::Array&lt; int &gt; &amp;cols, const mfem::Array&lt; int &gt; &amp;colMapper, mfem::DenseMatrix &amp;A_sub)</td></tr>
<tr class="memdesc:ad4246dcf5055f29128164b2ad25c0f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a submatrix from a sparse matrix, return it dense.  <a href="#ad4246dcf5055f29128164b2ad25c0f76">More...</a><br/></td></tr>
<tr class="separator:ad4246dcf5055f29128164b2ad25c0f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1febf87506d25d8a9b4744cf77ff7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a5a1febf87506d25d8a9b4744cf77ff7f">smoothg::ExtractColumns</a> (const mfem::DenseMatrix &amp;A, const mfem::Array&lt; int &gt; &amp;col_to_ref, const mfem::Array&lt; int &gt; &amp;subcol_to_ref, mfem::Array&lt; int &gt; &amp;ref_workspace, mfem::DenseMatrix &amp;A_sub, int row_offset=0)</td></tr>
<tr class="memdesc:a5a1febf87506d25d8a9b4744cf77ff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract columns from a dense matrix (A) to another dense matrix (A_sub)  <a href="#a5a1febf87506d25d8a9b4744cf77ff7f">More...</a><br/></td></tr>
<tr class="separator:a5a1febf87506d25d8a9b4744cf77ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a5e9d52f60e116a5026a1992b62dfe0cc">smoothg::Full</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;Adense)</td></tr>
<tr class="memdesc:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of a SparseMatrix.  <a href="#a5e9d52f60e116a5026a1992b62dfe0cc">More...</a><br/></td></tr>
<tr class="separator:a5e9d52f60e116a5026a1992b62dfe0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7d1e6bee3cd75b7885d7b69ae5b5526f">smoothg::FullTranspose</a> (const mfem::SparseMatrix &amp;Asparse, mfem::DenseMatrix &amp;AdenseT)</td></tr>
<tr class="memdesc:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a DenseMatrix with the entries of transpose of a SparseMatrix.  <a href="#a7d1e6bee3cd75b7885d7b69ae5b5526f">More...</a><br/></td></tr>
<tr class="separator:a7d1e6bee3cd75b7885d7b69ae5b5526f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2264079f7cc4cecd453569a1c0354ad3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2264079f7cc4cecd453569a1c0354ad3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2264079f7cc4cecd453569a1c0354ad3">smoothg::Concatenate</a> (const mfem::Vector &amp;a, const mfem::DenseMatrix &amp;b, mfem::DenseMatrix &amp;C)</td></tr>
<tr class="memdesc:a2264079f7cc4cecd453569a1c0354ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend the (column) vector a to the matrix b. <br/></td></tr>
<tr class="separator:a2264079f7cc4cecd453569a1c0354ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3393af3ae95d1a28009e2784476ba92c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3393af3ae95d1a28009e2784476ba92c">smoothg::Deflate</a> (mfem::DenseMatrix &amp;a, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3393af3ae95d1a28009e2784476ba92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all column vectors of a orthogonal to v.  <a href="#a3393af3ae95d1a28009e2784476ba92c">More...</a><br/></td></tr>
<tr class="separator:a3393af3ae95d1a28009e2784476ba92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb6ee2276b932e03d6bd3d9d8a4921d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#aecb6ee2276b932e03d6bd3d9d8a4921d">smoothg::orthogonalize_from_vector</a> (mfem::Vector &amp;vec, const mfem::Vector &amp;wrt)</td></tr>
<tr class="memdesc:aecb6ee2276b932e03d6bd3d9d8a4921d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector against wrt.  <a href="#aecb6ee2276b932e03d6bd3d9d8a4921d">More...</a><br/></td></tr>
<tr class="separator:aecb6ee2276b932e03d6bd3d9d8a4921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2bcfe4bfbd5b1cc452acd5139b512b1b">smoothg::par_orthogonalize_from_constant</a> (mfem::Vector &amp;vec, int globalsize)</td></tr>
<tr class="memdesc:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalize this vector from the constant vector.  <a href="#a2bcfe4bfbd5b1cc452acd5139b512b1b">More...</a><br/></td></tr>
<tr class="separator:a2bcfe4bfbd5b1cc452acd5139b512b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad61b4c310f8bb76f5524294d46b8ce4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::par_orthogonalize_from_constant</b> (mfem::HypreParVector &amp;vec)</td></tr>
<tr class="separator:ad61b4c310f8bb76f5524294d46b8ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d80d522d87be6998895981663dcb336"><td class="memItemLeft" align="right" valign="top">std::vector&lt; mfem::Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a2d80d522d87be6998895981663dcb336">smoothg::get_blocks</a> (const std::vector&lt; std::unique_ptr&lt; mfem::BlockVector &gt;&gt; &amp;blockvecs, int block_num)</td></tr>
<tr class="separator:a2d80d522d87be6998895981663dcb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memItemLeft" align="right" valign="top">mfem::DenseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a7b7f3460c5e52ae27462a9a81a1495df">smoothg::get_sq_differences_matrix</a> (const std::vector&lt; mfem::Vector &gt; &amp;vecs, const mfem::SparseMatrix *inner_prod_mat, bool diag_sq_norms)</td></tr>
<tr class="separator:a7b7f3460c5e52ae27462a9a81a1495df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b97167d68e040b91c3c8eba672c67e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b97167d68e040b91c3c8eba672c67e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6b97167d68e040b91c3c8eba672c67e9">smoothg::GenerateOffsets</a> (MPI_Comm comm, int N, HYPRE_Int loc_sizes[], mfem::Array&lt; HYPRE_Int &gt; *offsets[])</td></tr>
<tr class="memdesc:a6b97167d68e040b91c3c8eba672c67e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs. <br/></td></tr>
<tr class="separator:a6b97167d68e040b91c3c8eba672c67e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72242e6f25ceaa18cdce6ca81c41ba73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a72242e6f25ceaa18cdce6ca81c41ba73">smoothg::GenerateOffsets</a> (MPI_Comm comm, int local_size, mfem::Array&lt; HYPRE_Int &gt; &amp;offsets)</td></tr>
<tr class="memdesc:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the "start" array for HypreParMatrix based on the number of local true dofs Single case. <br/></td></tr>
<tr class="separator:a72242e6f25ceaa18cdce6ca81c41ba73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1fd264bdb38ec3fc1079fbbc567299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1fd264bdb38ec3fc1079fbbc567299"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>smoothg::IsDiag</b> (const mfem::SparseMatrix &amp;A)</td></tr>
<tr class="separator:aef1fd264bdb38ec3fc1079fbbc567299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a700414304bda429eed073858c70107"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a700414304bda429eed073858c70107"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3a700414304bda429eed073858c70107">smoothg::InnerProduct</a> (const mfem::Vector &amp;weight, const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a3a700414304bda429eed073858c70107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weighted l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a3a700414304bda429eed073858c70107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c164d11d16e6049109e7bc2083cfe24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c164d11d16e6049109e7bc2083cfe24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a6c164d11d16e6049109e7bc2083cfe24">smoothg::InnerProduct</a> (const mfem::Vector &amp;u, const mfem::Vector &amp;v)</td></tr>
<tr class="memdesc:a6c164d11d16e6049109e7bc2083cfe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the usual l2 inner product between u and v. <br/></td></tr>
<tr class="separator:a6c164d11d16e6049109e7bc2083cfe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a0ec315121a31884025776fb7b38de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; mfem::HypreParMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a97a0ec315121a31884025776fb7b38de">smoothg::BuildEntityToTrueEntity</a> (const mfem::HypreParMatrix &amp;entity_trueentity_entity)</td></tr>
<tr class="memdesc:a97a0ec315121a31884025776fb7b38de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct entity to true entity table from entity_trueentity_entity.  <a href="#a97a0ec315121a31884025776fb7b38de">More...</a><br/></td></tr>
<tr class="separator:a97a0ec315121a31884025776fb7b38de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adfe04363602226ba2fc6bca5b60c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1adfe04363602226ba2fc6bca5b60c27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a1adfe04363602226ba2fc6bca5b60c27">smoothg::BooleanMult</a> (const mfem::SparseMatrix &amp;mat, const mfem::Array&lt; int &gt; &amp;vec, mfem::Array&lt; int &gt; &amp;out)</td></tr>
<tr class="memdesc:a1adfe04363602226ba2fc6bca5b60c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">out = bool(mat) * bool(vec) Compute mat * vec, with entries of mat and vec treated as boolean. For mat, entries in the matrix graph are treated as 1, otherwise 0. <br/></td></tr>
<tr class="separator:a1adfe04363602226ba2fc6bca5b60c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e21d37d3d14ccd40e6d645509ca89f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e21d37d3d14ccd40e6d645509ca89f"></a>
unique_ptr&lt; mfem::HypreParMatrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a06e21d37d3d14ccd40e6d645509ca89f">smoothg::Copy</a> (const mfem::HypreParMatrix &amp;mat)</td></tr>
<tr class="memdesc:a06e21d37d3d14ccd40e6d645509ca89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of mfem::HypreParMatrix. <br/></td></tr>
<tr class="separator:a06e21d37d3d14ccd40e6d645509ca89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa7a68d09e4d3c9429124efcdec39d"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#ab9fa7a68d09e4d3c9429124efcdec39d">smoothg::GetDiag</a> (const mfem::HypreParMatrix &amp;mat)</td></tr>
<tr class="separator:ab9fa7a68d09e4d3c9429124efcdec39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d979298b1571e0185050fafb01fc024"><td class="memItemLeft" align="right" valign="top">mfem::SparseMatrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesmoothg.html#a3d979298b1571e0185050fafb01fc024">smoothg::GetOffd</a> (const mfem::HypreParMatrix &amp;mat)</td></tr>
<tr class="separator:a3d979298b1571e0185050fafb01fc024"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementations of some utility routines for linear algebra. </p>
<p>These are implemented with and operate on MFEM data structures. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
